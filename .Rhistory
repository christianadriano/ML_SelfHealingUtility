color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(1:max(dataf$CRITICALITY)));
fileName<-"MLDATA2_data.csv";
fileName<-"MLDATA2_STATIC";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
fileName<-"MLDATA2_STATIC";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_histogram(binwidth = 0.5,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency");
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_histogram(binwidth = 0.2,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(1:max(dataf$CRITICALITY)));
max(dataf$CRITICALITY;
ggplot(data=dataf, aes(x=dataf$RELIABILITY)) +
geom_histogram(binwidth = 0.1,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$RELIABILITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component reliability distribution")+
labs(x="Reliability of the component",
y="Frequency");
ggplot(data=dataf, aes(x=dataf$CONNECTIVITY)) +
geom_bar(alpha=.2, position="identity",stat = "count")+
geom_vline(aes(xintercept=mean(dataf$CONNECTIVITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component Connectivity distribution")+
scale_x_discrete(limits=c(1:20))+
labs(x="Connectivity of the component",
y="Frequency");
#
#Correlations
# Data is not normal
shapiro.test(dataf$UTILITY.DROP);
shapiro.test(dataf$CRITICALITY);
shapiro.test(dataf$CONNECTIVITY);
shapiro.test(dataf$RELIABILITY);
matrixInput<-data.frame(dataf$UTILITY.DROP,dataf$CRITICALITY,dataf$CONNECTIVITY,dataf$RELIABILITY);
colnames(matrixInput)<-c("Utility_Drop","Criticality","Connectivity","Reliability");
cor(matrixInput, method="kendall",use="pairwise");
#               Utility_Drop Criticality Connectivity Reliability
# Utility_Drop    1.0000000   0.8496351    0.9023943   0.3956244
# Criticality     0.8496351   1.0000000    0.6542992   0.4622369
# Connectivity    0.9023943   0.6542992    1.0000000   0.3286646
# Reliability     0.3956244   0.4622369    0.3286646   1.0000000
#As we can see that the data is medium to strongly correlated
}
max(dataf$CRITICALITY);
min(dataf$CRITICALITY);
fileName<-"MLDATA2_STATIC";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
fileName<-"MLDATA2_STATIC_v";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
fileName<-"test.csv";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
fileName<-"MLDATA2_STATIC_v.csv";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
fileName<-"MLDATA2_STATIC_v.csv";
setwd("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//");
data_all <- read.csv(fileName,header = TRUE,sep=",");
dataf <- data.frame(data_all);
summary(dataf)
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_histogram(binwidth = 0.2,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(1:max(dataf$CRITICALITY)));
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_histogram(binwidth = 0.2,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(1:max(dataf$CRITICALITY)));
min(dataf$CRITICALITY);
max(dataf$CRITICALITY);
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_histogram(binwidth = 0.2,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CRITICALITY):max(dataf$CRITICALITY)));
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_histogram(binwidth = 0.2,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CRITICALITY):max(dataf$CRITICALITY)));
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CRITICALITY):max(dataf$CRITICALITY)));
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$UTILITY.DROP):max(dataf$UTILITY.DROP)));
max(dataf$UTILITY.DROP)
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency");
summary(dataf);
ggplot(data=dataf, aes(x=dataf$RELIABILITY)) +
geom_histogram(binwidth = 0.1,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$RELIABILITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component reliability distribution")+
labs(x="Reliability of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$RELIABILITY):max(dataf$RELIABILITY)));
ggplot(data=dataf, aes(x=dataf$CONNECTIVITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CONNECTIVITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component Connectivity distribution")+
scale_x_discrete(limits=c(1:20))+
labs(x="Connectivity of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CONNECTIVITY):max(dataf$CONNECTIVITY)));
ggplot(data=dataf, aes(x=dataf$CONNECTIVITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CONNECTIVITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component Connectivity distribution")+
labs(x="Connectivity of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CONNECTIVITY):max(dataf$CONNECTIVITY)));
ggplot(data=dataf, aes(x=dataf$CONNECTIVITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CONNECTIVITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component Connectivity distribution")+
labs(x="Connectivity of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CONNECTIVITY):max(dataf$CONNECTIVITY)));
shapiro.test(dataf$UTILITY.DROP);
shapiro.test(dataf$CRITICALITY);
shapiro.test(dataf$CONNECTIVITY);
shapiro.test(dataf$RELIABILITY);
matrixInput<-data.frame(dataf$UTILITY.DROP,dataf$CRITICALITY,dataf$CONNECTIVITY,dataf$RELIABILITY);
colnames(matrixInput)<-c("Utility_Drop","Criticality","Connectivity","Reliability");
cor(matrixInput, method="kendall",use="pairwise");
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency");
ggplot(data=dataf, aes(x=dataf$CRITICALITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CRITICALITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component criticality distribution")+
labs(x="Criticality of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CRITICALITY):max(dataf$CRITICALITY)));
ggplot(data=dataf, aes(x=dataf$RELIABILITY)) +
geom_histogram(binwidth = 0.1,alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$RELIABILITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component reliability distribution")+
labs(x="Reliability of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$RELIABILITY):max(dataf$RELIABILITY)));
ggplot(data=dataf, aes(x=dataf$CONNECTIVITY)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$CONNECTIVITY, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Component Connectivity distribution")+
labs(x="Connectivity of the component",
y="Frequency")+
scale_x_discrete(limits=c(min(dataf$CONNECTIVITY):max(dataf$CONNECTIVITY)));
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency")+
scale_x_discrete(limits=c(1:25));
ggplot(data=dataf, aes(x=dataf$UTILITY.DROP)) +
geom_bar(alpha=.2, position="identity")+
geom_vline(aes(xintercept=mean(dataf$UTILITY.DROP, na.rm=T)),   # Ignore NA values for mean
color="red", linetype="dashed", size=1) +
ggtitle("Utility drop distribution")+
labs(x="Utility drop from disconnecting a component",
y="Frequency");
install.packages("ir.pca");
library (ir.pca);
# load data
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA_static.csv");
summary(data_df);
install.packages("ir.pca");
library (ir.pca);
# load data
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA_static.csv");
summary(data_df);
data_df<-loadData(fileName="MLDATAStatic.csv");
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
unite(data_df, decision, c(data_df$FAILURE.NAME,data_df$AFFECTED.COMPONENT,data_df$RULE), remove=FALSE);
library(tidyr)
unite(data_df, decision, c(data_df$FAILURE.NAME,data_df$AFFECTED.COMPONENT,data_df$RULE), remove=FALSE);
unite(data_df, decision, c(data_df$FAILURE.NAME,data_df$AFFECTED.COMPONENT,data_df$RULE), remove=FALSE);
unite(data_df, decision, c(data_df$FAILURE.NAME,data_df$AFFECTED.COMPONENT), remove=FALSE);
unite(data_df, decision, c(data_df$FAILURE.NAME,data_df$AFFECTED.COMPONENT), remove=FALSE);
library(tidyr)
unite(data_df, decision, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
tableF<-unite(data_df, decision, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
tableF
head(tableF)
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
titles(data_df)
top(data_df)
colnames(data_df)
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
#merge columns Failure.Name, Affected.Component, Rule
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
names<-c("Utility_Drop","Criticality","Connectity","Reliability","Decision");
colnames(features_df) <- names;
# consider only the feature columns
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY,dataf$DECISION);
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
# consider only the feature columns
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY,
dataf$DECISION);
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY,
dataf$DECISION);
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY,
data_df$DECISION);
names<-c("Utility_Drop","Criticality","Connectity","Reliability","Decision");
colnames(features_df) <- names;
set.seed(8850);
g<- runif((nrow(data_df))); #generates a random distribution
features_df <- features_df[order(g),];
# apply PCA - scale. = TRUE is highly
# advisable, but default is FALSE.
features_pca <- prcomp(features_df,center=TRUE,scale=TRUE);
print(features_pca);
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY);
names<-c("Utility_Drop","Criticality","Connectity","Reliability");
colnames(features_df) <- names;
set.seed(8850);
g<- runif((nrow(data_df))); #generates a random distribution
features_df <- features_df[order(g),];
features_pca <- prcomp(features_df,center=TRUE,scale=TRUE);
print(features_pca);
decision <-data_df[,1];
decision
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
#-----------------------------------------------------------
#Scramble the dataset before extracting the training set.
set.seed(8850);
g<- runif((nrow(data_df))); #generates a random distribution
data_df <- data_df[order(g),];
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY);
names<-c("Utility_Drop","Criticality","Connectity","Reliability");
colnames(features_df) <- names;
features_pca <- prcomp(features_df,center=TRUE,scale=TRUE);
print(features_pca);
plot(features_pca, type="l");
summary(features_pca);
install.packages("devtools")
library(devtools)
install.packages("scales")
library(scales)
install_github("ggbiplot", "vqv")
library(ggbiplot)
install.packages("scales")
decision <-data_df[,1];
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df[,1], ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df[,1], ellipse = TRUE,
circle = TRUE)
dim(data_df[,1])
dim(data_df[1,0])
dim(data_df[1,])
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$DECISION, ellipse = TRUE,
circle = TRUE)
features_pca
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$DECISION, ellipse = FALSE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$RULE, ellipse = FALSE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$FAILURE.NAME, ellipse = FALSE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$AFFECTED.COMPONENT, ellipse = FALSE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
#-----------------------------------------------------------
#Scramble the dataset before extracting the training set.
set.seed(8850);
g<- runif((nrow(data_df))); #generates a random distribution
data_df <- data_df[order(g),];
#merge columns Failure.Name, Affected.Component, Rule
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
# consider only the feature columns
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY);
#                        data_df$DECISION);
names<-c("Utility_Drop","Criticality","Connectity","Reliability");
colnames(features_df) <- names;
features_pca <- prcomp(features_df,center=TRUE,scale=TRUE);
print(features_pca);
plot(features_pca, type="l");
summary(features_pca);
plot_pca<-function(group){
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = group, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
}
plot_pca(data_df$FAILURE.NAME);
require(caret);
trans = preProcess(features_df,
method=c("BoxCox", "center",
"scale", "pca"))
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY);
names<-c("Utility_Drop","Criticality","Connectity","Reliability");
colnames(features_df) <- names;
require(caret);
trans = preProcess(features_df,
method=c("BoxCox", "center",
"scale", "pca"))
features_pca= predict(trans, features_df)
print(features_pca);
plot(features_pca, type="l");
summary(features_pca);
trans$loadings
trans$rotation
plot_pca(data_df$FAILURE.NAME);
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$FAILURE.NAME, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
plot_pca(data_df$AFFECTED.COMPONENT);
plot_pca<-function(group,pca_model){
g <- ggbiplot(pca_model, obs.scale = 1, var.scale = 1,
groups = group, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
}
plot_pca(data_df$FAILURE.NAME,features_pca);
plot_pca(group=data_df$FAILURE.NAME,pca_model=features_pca);
plot_pca<-function(group_classes,pca_model){
g <- ggbiplot(pca_model, obs.scale = 1, var.scale = 1,
groups = group_classes, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
}
plot_pca(group=data_df$FAILURE.NAME,pca_model=features_pca);
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$AFFECTED.COMPONENT, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
g <- ggbiplot(features_pca, obs.scale = 1, var.scale = 1,
groups = data_df$AFFECTED.COMPONENT, ellipse = FALSE,
circle = TRUE);
source("C://Users//chris//OneDrive//Documentos//GitHub//ML_SelfHealingUtility//loadData.R");
data_df<-loadData(fileName="MLDATA2_STATIC.csv");
summary(data_df);
#-----------------------------------------------------------
#Scramble the dataset before extracting the training set.
set.seed(8850);
g<- runif((nrow(data_df))); #generates a random distribution
data_df <- data_df[order(g),];
#merge columns Failure.Name, Affected.Component, Rule
library(tidyr)
data_df<-unite(data_df, DECISION, c("FAILURE.NAME","AFFECTED.COMPONENT","RULE"), remove=FALSE);
# consider only the feature columns
features_df<-data.frame(data_df$UTILITY.DROP,data_df$CRITICALITY,
data_df$CONNECTIVITY,data_df$RELIABILITY);
#                        data_df$DECISION);
names<-c("Utility_Drop","Criticality","Connectity","Reliability");
colnames(features_df) <- names;
# apply PCA - scale. = TRUE is highly
# advisable, but default is FALSE.
features_pca <- prcomp(features_df,center=TRUE,scale=TRUE);
plot_pca<-function(group_classes,pca_model){
g <- ggbiplot(pca_model, obs.scale = 1, var.scale = 1,
groups = group_classes, ellipse = FALSE,
circle = TRUE);
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top');
print(g);
}
plot_pca(group=data_df$FAILURE.NAME,pca_model=features_pca);
plot_pca(group_classes=data_df$FAILURE.NAME,pca_model=features_pca);
plot_pca(group_classes=data_df$AFFECTED.COMPONENT,pca_model=features_pca);
plot_pca(group_classes=data_df$RULE,pca_model=features_pca);
data_df<-unite(data_df, FAILURE_RULE, c("FAILURE.NAME","RULE"), remove=FALSE);
data_df<-unite(data_df, FAILURE_COMPONENT, c("FAILURE.NAME","AFFECTED.COMPONENT"), remove=FALSE);
data_df<-unite(data_df, RULE_COMPONENT, c("RULE","AFFECTED.COMPONENT") , remove=FALSE);
plot_pca(group_classes=data_df$FAILURE_RULE,pca_model=features_pca);
plot_pca(group_classes=data_df$RULE_COMPONENT,pca_model=features_pca);
plot_pca(group_classes=data_df$FAILURE_COMPONENT,pca_model=features_pca);
